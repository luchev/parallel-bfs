 Алгоритъмът който реализирате - task decomposition || data decomposition || both.

Архитектура на приложението - диаграма на нишките, например master/slave relation(s), кой кого пуска, чака, уведомява и т.н. Последното като картинка и/или обяснение.

Шаблони (design patterns) за използване на нишки - Worker pool

Speed up информация (т.е. Tp/Sp/Ep) на база резултатите от тестовете. Тоест за една и съща големина на задачата (харесвате си някаква), 

Диаграми за работата на отделните части

Средно време за работа

На каква ОС работи и какво му трябва да се пусне

Динамично/статично балансиране

гранулярност?

Модел на паралелизма

Софтуерна архитектура - master-slaves например

модел на комуникацията/синхронизацията между процесите GM|DM SV|MP

локално/глобално синхронен или асинхронен алгоритъм

Sp = T1/Tp – е ускорението

Ep = Sp/p – е ефективността

# Паралелно обхождане на граф

**Иван Лучев, 62135, Софтуерно Инженерство 3ти курс**

[TOC]

В този документ ще разгледаме обхождане на граф $G(V,E)$ като крайната цел е да получим ефективен алгоритъм, който ни връща като резултат как изглежда функцията на бащите $p(v)$ за някое от покриващите дървета на този граф. Ще разгледаме няколко паралелни алгоритъма, какво ускорение ни предлагат пред последователните обхождания и колко добре скалират с увеличаване на броя на нишките с които работим.

Добре е да уточним, че се фокусираме върху графи с много ребра (dense graphs) и за представянето ще използваме матрица на съседство.

## Анализ на проблема

Задачата е зададена с два варианта на изпълнение.

**Вариант 1: Генериране на граф**, обхождане на графа и записване на резултата и графа във файлове.

![](https://i.imgur.com/YJsk1vi.png)

**Вариант 2: Прочитане на граф от файл**, обхождане на графа и записване на резултата във файл.

![](https://i.imgur.com/NbUqhbc.png)

От горните две диаграми на изпълнение на програмата може да видим, че имаме архитектура **Pipes & Filters**. Тъй като всяка следваща стъпка в програмата разчита на резултата от предишната (пр. Обхождането на граф предполага че разполагаме с граф, било то прочетен от файл или генериран). При такава архитектура, за да постигнем максимално бързо изпълнение на многопроцесорна машина е необходимо да паралелизираме всяка една независима стъпка на програмата.

### Сложност на операциите

За да преценим кои операции е удачно да бъдат паралелизирани трябва да оценим сложнсоттан всяка една от тях. Като имаме в предвид че разглеждаме плътни графи, т.е $|E| \rightarrow |V|^2 $

| Операция                                                    | Сложност                              |
| ----------------------------------------------------------- | ------------------------------------- |
| Генериране на граф $G(V,E)$                                 | $\Theta(|E|)=\Theta(|V|^2)$           |
| Прочитане на граф от файл $G(V,E)$                          | $\Theta(|E|)=\Theta(|V|^2)$           |
| Обхождане на граф $G(V,E)$                                  | $\mathcal{O}(|E|)=\mathcal{O}(|V|^2)$ |
| Запаметяване на функцията на бащите $p(v)$ за граф $G(V,E)$ | $\Theta(|V|)$                         |
| Запаметяване на граф $G(V,E)$ във файл                      | $\Theta(|E|)=\Theta(|V|^2)$           |

Запаметяване на функцията на бащите е най-бързата операция - единствената такава, която скалира линейно спрямо броя на върховете. Всички останали операции бавни - генериране, прочитане, обхождане и запаметяване на граф скалират квадратично спрямо броя на върховете на графа. За да постигнем максимално ускорение чрез използването на многонишков алгоритъм ще се фокусираме върху паралелизирането на бавните операции.

На следните 2 графики е представена архитектурата с операциите, които целим да направим многонишкови, за да ускорим тяхната обработка.

### Многонишкова архитектура на Вариант 1: Генериране на граф

![](https://i.imgur.com/vYBb7yT.png)

### Многонишкова архитектура на Вариант 2: Прочитане на граф от файл

![](https://i.imgur.com/H6KShGA.png)

## Хардуер на който ще извършваме тестовете

Сравнението на алгоритмите, тяхната ефективност, възможност да бъдат паралелизирани и колко добре скалират с увеличаване на броя на процесорите ще тестваме на две машини. Тук са показани най-важните характеристики на тези машини, които ще имат значение за изводите, които правим.

### 4-Core

```
CPU(s):               8
Thread(s) per core:   2
Core(s) per socket:   4
Socket(s):            1
CPU MHz:              2858.125
L1d cache:            128 KiB
RAM:                  8GB
```

### 16-Core

```
CPU(s):               32 
Thread(s) per core:   2 
Core(s) per socket:   8 
Socket(s):            2 
CPU MHz:              1880.017 
L1d cache:            32K 
RAM:                  64G
```

## Анализ на технологията

Преди да разгледаме и анализираме алгоритми за всяка една операция, описана в горната точка, ще изберем подходяща технология за тестване.

Ще разгледаме Java, C++ и Go. Ще тестваме предимствата и недостатъците на всяка една технология като използваме един и същ алгоритъм за генериране на насочен граф.

Всеки тест е повторен по 3 пъти на машината **16-Core**. Но тъй като избирането на технология не е фокус на този документ, ще разгледаме само най-добрите резултати от тестванет на базата на които ще направим изводи.

### Описание на алгоритъма за анализ на технологията

Генерираме насочен граф. Използваме **статично балансиране** - разпределяме върховете на графа на броя на нишките с които работим. Всяка нишка обработва еднакъв брой върха на принципа на **Round-Robin**. По този начин всяка нишка генерира ребрата на равен брой върхове.

Пример: ако имаме 16 нишки, то нишка 1 обработва върхове, чиито индекси дават модул 1 при деление на 16 (върхове 1, 17, 33, ...), нишка 3 обработва върховете, чиито индекси дават модул 3 при деление на 16 (върхове 3, 19, 35, ...).

### Java

#### Резултат от тестването

| Math.random | Threads | Vertices | Time (seconds) | Speedup |
| ----------- | ------- | -------- | -------------- | ------- |
|             | 1       | 10,000   | 3.0796         | 1       |
|             | 4       | 10,000   | 26.1181        | 0.11    |

| ThreadLocalRandom | Threads | Vertices | Time (seconds) | Speedup |
| ----------------- | ------- | -------- | -------------- | ------- |
|                   | 1       | 40,000   | 10.3472        | 1       |
|                   | 4       | 40,000   | 3.4738         | 2.97    |
|                   | 8       | 40,000   | 2.3720         | 4.36    |
|                   | 16      | 40,000   | 2.0972         | 4.93    |
|                   | 32      | 40,000   | 1.9776         | 5.23    |

#### Извод

Java има два вградени метода за генериране на случайни числа.

**Math.random** - изключително бавен метод за генериране на случайни числа, който се забавя 10x когато увеличим броят на нишките от 1 на 4. Повече тестове не са необходими. Math.random е неблагоприятен за паралелно обработване.

**ThreadLocalRandom** - бърз алгоритъм за генериране на случайни числа, който работи добре с повече нишки. За съжаление ускорението не се доближава до оптималното линейно като при 16 нишки достигаме 5x ускорение, при оптимално 16x. ThreadLocalRandom е значително по-добър от Math.random, но не е достатъчно добър за оптимални резултати.

> Java не е подходяща технология, защото не предоставя достатъчно добро ускорение с увеличаване на броя на нишките на които работим

### C++

#### Резултати от тестването

| Mersenne Twister | Threads | Vertices | Time (seconds) | Speedup |
| ---------------- | ------- | -------- | -------------- | ------- |
| Non-Threaded     | 1       | 10,000   | 32 минути      | 1       |
| Non-Threaded     | 16      | 10,000   | 43 минути      | 0.74    |
| Threaded         | 1       | 10,000   | 6.8707         | 1       |
| Threaded         | 4       | 10,000   | 1.7845         | 3.85    |
| Threaded         | 8       | 10,000   | 0.9108         | 7.54    |
| Threaded         | 16      | 10,000   | 0.5386         | 12.75   |
| Threaded         | 32      | 10,000   | 0.4383         | 15.67   |

| Marsaglia's xorshf | Threads | Vertices | Time (seconds) | Speedup |
| ------------------ | ------- | -------- | -------------- | ------- |
| Non-Threaded       | 1       | 20,000   | 3.6333         | 1       |
| Non-Threaded       | 4       | 20,000   | 10.3713        | 0.35    |
| Threaded           | 1       | 20,000   | 3.4334         | 1       |
| Threaded           | 4       | 20,000   | 0.9047         | 3.7     |
| Threaded           | 8       | 20,000   | 0.4735         | 7.2     |
| Threaded           | 16      | 20,000   | 0.3204         | 10.71   |
| Threaded           | 32      | 20,000   | 0.2857         | 12      |

| Algorithm (threaded) | Threads | Vertices | Time (seconds) | Speedup |
| -------------------- | ------- | -------- | -------------- | ------- |
| Mersenne Twister     | 1       | 50,000   | 172.0770       | 1       |
| Mersenne Twister     | 16      | 50,000   | 12.0559        | 14.27   |
| Mersenne Twister     | 32      | 50,000   | 9.51459        | 18      |
| Marsaglia's xorshf   | 1       | 50,000   | 21.4722        | 1       |
| Marsaglia's xorshf   | 16      | 50,000   | 1.6168         | 13.28   |
| Marsaglia's xorshf   | 32      | 50,000   | 1.6420         | 13      |

#### Извод

C++ има вграден алгоритъм Mersenne Twister и ще имплементираме Marsaglia's xorshf.

**Mersenne Twister** работи сравнително бавно, за това тестваме с по-малък брой върхове. Въпреки това алгоритъма предоставя много добро ускорение в сравнение с Java, като при 16 нишки получаваме ускорение 12.17x.

**Marsaglia's xorshf** e в пъти по-бърз от Mersenne Twister. Поради тази причина увеличаваме броят на върховете на 20, 000, за да може да оценим ускорението. Алгоритъмът не скалира толкова добре спрямо броят нишки като при 16 нишки получаваме 10.71x ускорение, което е 2 пъти по-добро от това на Java, но е значително по-лошо от ускорението на Mersenne Twister.

>  За голям брой върхове въпреки че ускорението на Marsaglia's xorshf е по-лошо от това на Mersenne Twister, Marsaglia's xorshf работи по-бързо и би бил-по-добрият избор за малък брой ядра (16).

### Go

#### Резултати от тестовете

| Cryptographic pseudo-random number sequence generator (CPRNG) | Threads | Vertices | Time (seconds) | Speedup |
| ------------------------------------------------------------ | ------- | -------- | -------------- | ------- |
|                                                              | 1       | 40,000   | 12.8282        | 1       |
|                                                              | 4       | 40,000   | 6.3824         | 2       |
|                                                              | 8       | 40,000   | 5.4181         | 2.36    |
|                                                              | 16      | 40,000   | 5.7462         | 2.23    |
|                                                              | 32      | 40,000   | 6.7325         | 1.9     |

| Pseudo-random number generator (PRNG) | Threads | Vertices | Time (seconds) | Speedup |
| ------------------------------------- | ------- | -------- | -------------- | ------- |
|                                       | 1       | 40,000   | 33.8937        | 1       |
|                                       | 4       | 40,000   | 8.3982         | 4       |
|                                       | 8       | 40,000   | 4.3595         | 7.77    |
|                                       | 16      | 40,000   | 2.4213         | 14      |
|                                       | 32      | 40,000   | 2.1362         | 15.86   |

| Pseudo-random number sequence generator (PRNG Sequence) | Threads | Vertices | Time (seconds) | Speedup |
| ------------------------------------------------------- | ------- | -------- | -------------- | ------- |
|                                                         | 1       | 40,000   | 4.5132         | 1       |
|                                                         | 4       | 40,000   | 1.2269         | 3.67    |
|                                                         | 8       | 40,000   | 0.6593         | 6.84    |
|                                                         | 16      | 40,000   | 0.3996         | 11.29   |
|                                                         | 32      | 40,000   | 0.3498         | 12.9    |

#### Извод

Go има 2 начина за генериране на случайни числа - криптографски (недетерминиран) и псевдо-случаен генератор (детерминиран).

Cryptographic pseudo-random number sequence generator (**CPRNG**) генерира случайни числа по недетерминистичен начин. Това забавя работата му изключително много и получаваме ускорение само 2.23x при 16 нишки.

Pseudo-random number generator (**PRNG**) генерира случайни числа по детерминистичен начин. Това позволява много по-добро ускорение с използването на повече нишки - до 14x ускорение.

Ако използваме locality на данните и генерираме поредица от случайни числа (**PRNG Sequence**) получаваме само 11.29x ускорение на 16 нишки, но поради locality получаваме 6 пъти по-добро време.

> За машина с малък брой ядра (16) PRNG Sequence е по-подходящ и работи по-бързо от PRNG, въпреки че не скалира толкова добре с броя нишки. Ако увеличим броят логически ядра на процесора или броят върхове PRNG ще е по-добрият алгоритъм.

## Избор на технология

![](https://i.imgur.com/1yuLyOd.png)

Най-добро ускорение на 32 нишки получаваме при Go - 15.86x (PRNG), като C++ (Mersenne Twister) е на второ място с 15.67x. Java е на последно място с 5.23x ускорение на 32 нишки.

За този документ ще изберем Go като технология за многонишкова обработка на данни. 

Важно е да забележим, че на машината на която се извършват тестовете има 16 физически ядра на процесора с hyperthreading, което ни показва че имаме 32 логически ядра. Въпреки това дори когато използваме 32 нишки получаваме оптимално ускорение 15.86x за алгоритъма PRNG на Go, което се доближава до броят на физическите 16 ядра, но по никакъв начин не се доближава до логическите 32 ядра. Това означава, че може да очакваме ускорение на програмата в зависимост от това колко физически ядра има процесора, не колко логически.